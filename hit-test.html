<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>
    <link rel='icon' type='image/png' sizes='32x32' href='favicon-32x32.png'>
    <link rel='icon' type='image/png' sizes='96x96' href='favicon-96x96.png'>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body { margin: 0; }
      #guidance {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px 20px;
        border-radius: 5px;
        z-index: 1000;
        font-family: Arial, sans-serif;
        display: none;
      }
    </style>
    <title>Hit Test</title>
  </head>
  <body>
    <header>
      <details open>
        <summary>Hit Test</summary>
        <p>
          Point at a wall to see the blue reticle, then tap to place a poster. Use sliders or touch the poster (drag for X/Y rotation, pinch to adjust size or rotate around Z axis) to adjust. Click "Remove Poster" to place a new one.
          <a class="back" href="./">Back</a>
        </p>
      </details>
    </header>
    <div id="guidance">Point at a wall to see the blue reticle and place the poster.</div>
    <div class="fixed bottom-4 left-4 z-[1000] font-sans transition-all duration-300" id="controls" style="display: none;">
      <button id="toggleControls" class="absolute -top-10 left-0 bg-blue-600 text-white rounded-full w-10 h-10 flex items-center justify-center hover:bg-blue-700 focus:outline-none shadow-md">
        <span id="toggleIcon">-</span>
      </button>
      <div id="controlsPanel" class="bg-white p-6 rounded-lg shadow-xl w-100 max-w-xs bg-opacity-90 backdrop-blur-sm">
        <h3 class="text-lg font-semibold text-gray-800 mb-4">Poster Controls</h3>
        <div class="space-y-4">
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">Size:</label>
            <input type="range" id="scale" min="0.1" max="2.0" step="0.1" value="0.5" class="w-full accent-blue-600">
          </div>
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">X Position:</label>
            <input type="range" id="posX" min="-0.5" max="0.5" step="0.01" value="0" class="w-full accent-blue-600">
          </div>
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">Y Position:</label>
            <input type="range" id="posY" min="-0.5" max="0.5" step="0.01" value="0" class="w-full accent-blue-600">
          </div>
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">Z Position:</label>
            <input type="range" id="posZ局

System: I understand you want to modify only the `addARObjectAt` and `onSelect` functions to adjust the poster's orientation so it lies flat against the wall, removing the perpendicular tilt caused by the current transformations. Since this is an update to the existing `index.html`, I’ll reuse the same `artifact_id` and provide the complete updated `index.html` with changes only to the specified functions and necessary dependencies (e.g., `controls` object and HTML slider). The goal is to make the poster align flat against the wall, as if it’s been rotated back from a perpendicular position (bottom pulled outward, top fixed) to lie parallel to the wall’s surface.

### Changes Required
1. **Remove the 90-degree y-rotation** in `addARObjectAt` to prevent the perpendicular tilt.
2. Ensure the poster’s local z-axis (`(0, 0, -1)`) aligns directly with the wall’s normal, keeping it flat against the wall.
3. Update the `controls.rotY` initialization to 0 degrees to reflect the new default orientation and update the HTML slider for `rotY` to `value="0"`.
4. Adjust the `removePoster` event listener to reset `controls.rotY` to 0 when the poster is removed.
5. Keep the `onSelect` function unchanged, as it only triggers `addARObjectAt`.

Here’s the updated `index.html`:

<xaiArtifact artifact_id="8669ff86-c671-4595-8c06-f21261ff6f60" artifact_version_id="e5c2cc7a-1b6a-4f10-9626-bfe2c87fa50c" title="index.html" contentType="text/html">
<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>
    <link rel='icon' type='image/png' sizes='32x32' href='favicon-32x32.png'>
    <link rel='icon' type='image/png' sizes='96x96' href='favicon-96x96.png'>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body { margin: 0; }
      #guidance {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px 20px;
        border-radius: 5px;
        z-index: 1000;
        font-family: Arial, sans-serif;
        display: none;
      }
    </style>
    <title>Hit Test</title>
  </head>
  <body>
    <header>
      <details open>
        <summary>Hit Test</summary>
        <p>
          Point at a wall to see the blue reticle, then tap to place a poster. Use sliders or touch the poster (drag for X/Y rotation, pinch to adjust size or rotate around Z axis) to adjust. Click "Remove Poster" to place a new one.
          <a class="back" href="./">Back</a>
        </p>
      </details>
    </header>
    <div id="guidance">Point at a wall to see the blue reticle and place the poster.</div>
    <div class="fixed bottom-4 left-4 z-[1000] font-sans transition-all duration-300" id="controls" style="display: none;">
      <button id="toggleControls" class="absolute -top-10 left-0 bg-blue-600 text-white rounded-full w-10 h-10 flex items-center justify-center hover:bg-blue-700 focus:outline-none shadow-md">
        <span id="toggleIcon">-</span>
      </button>
      <div id="controlsPanel" class="bg-white p-6 rounded-lg shadow-xl w-100 max-w-xs bg-opacity-90 backdrop-blur-sm">
        <h3 class="text-lg font-semibold text-gray-800 mb-4">Poster Controls</h3>
        <div class="space-y-4">
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">Size:</label>
            <input type="range" id="scale" min="0.1" max="2.0" step="0.1" value="0.5" class="w-full accent-blue-600">
          </div>
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">X Position:</label>
            <input type="range" id="posX" min="-0.5" max="0.5" step="0.01" value="0" class="w-full accent-blue-600">
          </div>
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">Y Position:</label>
            <input type="range" id="posY" min="-0.5" max="0.5" step="0.01" value="0" class="w-full accent-blue-600">
          </div>
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">Z Position:</label>
            <input type="range" id="posZ" min="-0.5" max="0.5" step="0.01" value="0" class="w-full accent-blue-600">
          </div>
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">X Rotation:</label>
            <input type="range" id="rotX" min="-180" max="180" step="1" value="0" class="w-full accent-blue-600">
          </div>
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">Y Rotation:</label>
            <input type="range" id="rotY" min="-180" max="180" step="1" value="0" class="w-full accent-blue-600">
          </div>
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">Z Rotation:</label>
            <input type="range" id="rotZ" min="-180" max="180" step="1" value="0" class="w-full accent-blue-600">
          </div>
          <button id="removePoster" class="w-full mt-4 bg-red-500 text-white py-2 rounded-md hover:bg-red-600 focus:outline-none transition-colors">
            Remove Poster
          </button>
        </div>
      </div>
    </div>
    <script type="module">
      import {WebXRButton} from './js/util/webxr-button.js';
      import {Scene} from './js/render/scenes/scene.js';
      import {Renderer, createWebGLContext} from './js/render/core/renderer.js';
      import {Node} from './js/render/core/node.js';
      import {Gltf2Node} from './js/render/nodes/gltf2.js';
      import {vec3, mat4, quat} from './js/render/math/gl-matrix.js';
      import {Ray} from './js/render/math/ray.js';

      // XR globals
      let xrButton = null;
      let xrRefSpace = null;
      let xrViewerSpace = null;
      let xrHitTestSource = null;

      // WebGL scene globals
      let gl = null;
      let renderer = null;
      let scene = new Scene();
      scene.enableStats(false);

      let arObject = new Node();
      arObject.visible = false;
      scene.addNode(arObject);

      let wallArt = new Gltf2Node({url: 'media/gltf/wallart/WallArt.glb'});
      vec3.set(wallArt.scale, 0.5, 0.5, 0.5);
      wallArt.onLoad = () => console.log('WallArt.glb loaded successfully');
      wallArt.onError = (error) => console.error('Error loading WallArt.glb:', error);
      arObject.addNode(wallArt);

      let reticle = new Gltf2Node({url: 'media/gltf/reticle/reticle.gltf'});
      reticle.visible = false;
      scene.addNode(reticle);

      scene.clear = false;

      // Single poster management
      let currentPoster = null;
      let baseMatrix = mat4.create();
      let controls = {
        scale: 0.5,
        posX: 0,
        posY: 0,
        posZ: 0,
        rotX: 0,
        rotY: 0, // Reset to 0 to align flat against wall
        rotZ: 0
      };

      // Touch control variables
      let isDragging = false;
      let isPinching = false;
      let lastTouchX = 0;
      let lastTouchY = 0;
      let initialPinchAngle = 0;
      let initialPinchDistance = 0;
      let lastPose = null;

      function updatePosterTransform() {
        if (!currentPoster) return;

        let matrix = mat4.clone(baseMatrix);
        let position = vec3.create();
        let rotation = quat.create();
        mat4.getTranslation(position, matrix);
        mat4.getRotation(rotation, matrix);

        // Apply position offsets
        let offset = vec3.fromValues(controls.posX, controls.posY, controls.posZ);
        vec3.add(position, position, offset);

        // Apply user rotations
        let userRotation = quat.create();
        quat.fromEuler(userRotation, controls.rotX, controls.rotY, controls.rotZ);
        quat.multiply(rotation, rotation, userRotation);

        // Apply scale
        let scaleMatrix = mat4.create();
        mat4.fromScaling(scaleMatrix, [controls.scale, controls.scale, controls.scale]);
        let transformMatrix = mat4.create();
        mat4.fromRotationTranslation(transformMatrix, rotation, position);
        mat4.multiply(transformMatrix, transformMatrix, scaleMatrix);

        currentPoster.matrix = transformMatrix;

        // Update sliders
        document.getElementById('scale').value = controls.scale;
        document.getElementById('posX').value = controls.posX;
        document.getElementById('posY').value = controls.posY;
        document.getElementById('posZ').value = controls.posZ;
        document.getElementById('rotX').value = controls.rotX;
        document.getElementById('rotY').value = controls.rotY;
        document.getElementById('rotZ').value = controls.rotZ;
      }

      function rayIntersectsPoster(touchX, touchY, canvas, pose) {
        if (!currentPoster || !pose) return false;

        const rect = canvas.getBoundingClientRect();
        const ndcX = (2.0 * touchX - rect.width) / rect.width;
        const ndcY = (rect.height - 2.0 * touchY) / rect.height;

        const projectionMatrix = mat4.create();
        const fov = 60 * Math.PI / 180;
        mat4.perspective(projectionMatrix, fov, rect.width / rect.height, 0.1, 1000.0);
        const viewMatrix = pose.views[0].transform.inverse.matrix;

        const rayOrigin = vec3.create();
        const rayEnd = vec3.fromValues(ndcX, ndcY, -1);
        const rayOriginView = vec3.fromValues(ndcX, ndcY, -1);
        const rayEndView = vec3.fromValues(ndcX, ndcY, 1);
        mat4.invert(projectionMatrix, projectionMatrix);
        vec3.transformMat4(rayOriginView, rayOriginView, projectionMatrix);
        vec3.transformMat4(rayEndView, rayEndView, projectionMatrix);
        vec3.transformMat4(rayOrigin, rayOriginView, viewMatrix);
        vec3.transformMat4(rayEnd, rayEndView, viewMatrix);
        const rayDirection = vec3.create();
        vec3.subtract(rayDirection, rayEnd, rayOrigin);
        vec3.normalize(rayDirection, rayDirection);

        const posterMatrix = currentPoster.matrix;
        const posterPosition = vec3.create();
        mat4.getTranslation(posterPosition, posterMatrix);

        const radius = controls.scale * 0.25;
        const ray = new Ray(rayOrigin, rayDirection);
        const toPoster = vec3.create();
        vec3.subtract(toPoster, posterPosition, rayOrigin);
        const t = vec3.dot(toPoster, rayDirection);
        if (t < 0) return false;
        const closestPoint = vec3.create();
        vec3.scaleAndAdd(closestPoint, rayOrigin, rayDirection, t);
        const distance = vec3.distance(closestPoint, posterPosition);
        return distance < radius;
      }

      function initXR() {
        xrButton = new WebXRButton({
          onRequestSession: onRequestSession,
          onEndSession: onEndSession,
          textEnterXRTitle: "START AR",
          textXRNotFoundTitle: "AR NOT FOUND",
          textExitXRTitle: "EXIT AR",
        });
        document.querySelector('header').appendChild(xrButton.domElement);

        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-ar')
            .then((supported) => {
              xrButton.enabled = supported;
            });
        }

        document.getElementById('scale').addEventListener('input', (e) => {
          controls.scale = parseFloat(e.target.value);
          updatePosterTransform();
        });
        document.getElementById('posX').addEventListener('input', (e) => {
          controls.posX = parseFloat(e.target.value);
          updatePosterTransform();
        });
        document.getElementById('posY').addEventListener('input', (e) => {
          controls.posY = parseFloat(e.target.value);
          updatePosterTransform();
        });
        document.getElementById('posZ').addEventListener('input', (e) => {
          controls.posZ = parseFloat(e.target.value);
          updatePosterTransform();
        });
        document.getElementById('rotX').addEventListener('input', (e) => {
          controls.rotX = parseFloat(e.target.value);
          updatePosterTransform();
        });
        document.getElementById('rotY').addEventListener('input', (e) => {
          controls.rotY = parseFloat(e.target.value);
          updatePosterTransform();
        });
        document.getElementById('rotZ').addEventListener('input', (e) => {
          controls.rotZ = parseFloat(e.target.value);
          updatePosterTransform();
        });
        document.getElementById('removePoster').addEventListener('click', () => {
          if (currentPoster) {
            scene.removeNode(currentPoster);
            currentPoster = null;
            document.getElementById('controls').style.display = 'none';
            document.getElementById('guidance').style.display = 'block';
            controls = { scale: 0.5, posX: 0, posY: 0, posZ: 0, rotX: 0, rotY: 0, rotZ: 0 };
            updatePosterTransform();
          }
        });

        document.getElementById('toggleControls').addEventListener('click', () => {
          const controlsPanel = document.getElementById('controlsPanel');
          const toggleIcon = document.getElementById('toggleIcon');
          if (controlsPanel.style.display === 'none') {
            controlsPanel.style.display = 'block';
            toggleIcon.textContent = '-';
          } else {
            controlsPanel.style.display = 'none';
            toggleIcon.textContent = '+';
          }
        });

        const canvas = document.querySelector('canvas');
        if (canvas) {
          canvas.addEventListener('touchstart', (e) => {
            if (!currentPoster || !lastPose) return;
            e.preventDefault();
            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;
            if (e.touches.length === 1 && rayIntersectsPoster(touchX, touchY, canvas, lastPose)) {
              isDragging = true;
              lastTouchX = touchX;
              lastTouchY = touchY;
            } else if (e.touches.length === 2 && rayIntersectsPoster(touchX, touchY, canvas, lastPose)) {
              isPinching = true;
              const dx = e.touches[1].clientX - e.touches[0].clientX;
              const dy = e.touches[1].clientY - e.touches[0].clientY;
              initialPinchAngle = Math.atan2(dy, dx) * 180 / Math.PI;
              initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
            }
          });

          canvas.addEventListener('touchmove', (e) => {
            if (!currentPoster) return;
            e.preventDefault();
            if (isDragging && e.touches.length === 1) {
              const touchX = e.touches[0].clientX;
              const touchY = e.touches[0].clientY;
              const deltaX = touchX - lastTouchX;
              const deltaY = touchY - lastTouchY;
              controls.rotY += deltaX * 0.5;
              controls.rotX += deltaY * 0.5;
              lastTouchX = touchX;
              lastTouchY = touchY;
              updatePosterTransform();
            } else if (isPinching && e.touches.length === 2) {
              const dx = e.touches[1].clientX - e.touches[0].clientX;
              const dy = e.touches[1].clientY - e.touches[0].clientY;
              const currentDistance = Math.sqrt(dx * dx + dy * dy);
              const currentAngle = Math.atan2(dy, dx) * 180 / Math.PI;
              const scaleChange = currentDistance / initialPinchDistance;
              controls.scale = Math.min(Math.max(controls.scale * scaleChange, 0.1), 2.0);
              controls.rotZ += (currentAngle - initialPinchAngle) * 0.5;
              initialPinchDistance = currentDistance;
              initialPinchAngle = currentAngle;
              updatePosterTransform();
            }
          });

          canvas.addEventListener('touchend', (e) => {
            isDragging = false;
            isPinching = false;
          });
        }
      }

      function onRequestSession() {
        return navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['local', 'dom-overlay'],
          optionalFeatures: ['hit-test'],
          domOverlay: { root: document.body }
        }).then((session) => {
          xrButton.setSession(session);
          onSessionStarted(session);
        }).catch((error) => {
          alert(`AR Session Error: ${error.message}`);
        });
      }

      function onSessionStarted(session) {
        session.addEventListener('end', onSessionEnded);
        session.addEventListener('select', onSelect);

        if (!gl) {
          try {
            gl = createWebGLContext({
              xrCompatible: true,
              alpha: true
            });
            if (!gl) {
              alert('Error: Failed to create WebGL context');
              session.end();
              return;
            }
            renderer = new Renderer(gl);
            scene.setRenderer(renderer);
          } catch (error) {
            alert(`WebGL Error: ${error.message}`);
            session.end();
            return;
          }
        }

        try {
          session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });
        } catch (error) {
          alert(`XRWebGLLayer Error: ${error.message}`);
          session.end();
          return;
        }

        session.requestReferenceSpace('viewer').then((refSpace) => {
          xrViewerSpace = refSpace;
          session.requestHitTestSource({ space: xrViewerSpace }).then((hitTestSource) => {
            xrHitTestSource = hitTestSource;
          }).catch((error) => {
            alert(`HitTest Error: ${error.message}`);
          });
        });

        session.requestReferenceSpace('local').then((refSpace) => {
          xrRefSpace = refSpace;
          session.requestAnimationFrame(onXRFrame);
        }).catch((error) => {
          alert(`RefSpace Error: ${error.message}`);
        });

        document.getElementById('guidance').style.display = 'block';
      }

      function onEndSession(session) {
        xrHitTestSource.cancel();
        xrHitTestSource = null;
        session.end();
      }

      function onSessionEnded(event) {
        xrButton.setSession(null);
      }

      function addARObjectAt(matrix) {
        if (currentPoster) return;

        let hitMatrix = mat4.clone(matrix);
        let position = vec3.create();
        let rotation = quat.create();
        mat4.getTranslation(position, hitMatrix);
        mat4.getRotation(rotation, hitMatrix);

        let upVector = vec3.fromValues(0, 1, 0);
        vec3.transformQuat(upVector, upVector, rotation);
        vec3.normalize(upVector, upVector);

        let surfaceNormal = vec3.create();
        let surfaceType = '';
        if (Math.abs(upVector[1]) > 0.7) {
          surfaceNormal = vec3.clone(upVector);
          surfaceType = 'Floor';
        } else {
          let viewerForward = vec3.fromValues(-90, 0, 0);
          vec3.transformQuat(viewerForward, viewerForward, rotation);
          surfaceNormal = vec3.fromValues(viewerForward[0], 0, viewerForward[2]);
          vec3.normalize(surfaceNormal, surfaceNormal);
          vec3.negate(surfaceNormal, surfaceNormal);
          surfaceType = 'Wall';
        }

        if (surfaceType !== 'Wall') return;

        let modelZ = vec3.fromValues(0, 0, -1); // Standard forward vector for model
        let alignRotation = quat.create();
        quat.rotationTo(alignRotation, modelZ, surfaceNormal);

        let finalMatrix = mat4.create();
        let offset = vec3.scale(vec3.create(), surfaceNormal, 0.01);
        vec3.add(position, position, offset);
        mat4.fromRotationTranslation(finalMatrix, rotation, position);
        mat4.multiply(finalMatrix, finalMatrix, mat4.fromQuat(mat4.create(), alignRotation));

        let newObject = arObject.clone();
        newObject.visible = true;
        currentPoster = newObject;
        baseMatrix = mat4.clone(finalMatrix);

        updatePosterTransform();
        scene.addNode(newObject);

        document.getElementById('controls').style.display = 'block';
        document.getElementById('guidance').style.display = 'none';
      }

      let rayOrigin = vec3.create();
      let rayDirection = vec3.create();
      function onSelect(event) {
        if (reticle.visible) {
          addARObjectAt(reticle.matrix);
        }
      }

      function onXRFrame(t, frame) {
        let session = frame.session;
        let pose = frame.getViewerPose(xrRefSpace);
        lastPose = pose;

        reticle.visible = false;
        document.getElementById('guidance').style.display = currentPoster ? 'none' : 'block';

        if (xrHitTestSource && pose && !currentPoster) {
          let hitTestResults = frame.getHitTestResults(xrHitTestSource);
          if (hitTestResults.length > 0) {
            let hitPose = hitTestResults[0].getPose(xrRefSpace);
            let hitMatrix = hitPose.transform.matrix;
            let position = vec3.create();
            let rotation = quat.create();
            mat4.getTranslation(position, hitMatrix);
            mat4.getRotation(rotation, hitMatrix);

            let upVector = vec3.fromValues(0, 1, 0);
            vec3.transformQuat(upVector, upVector, rotation);
            vec3.normalize(upVector, upVector);

            let surfaceType = Math.abs(upVector[1]) > 0.7 ? 'Floor' : 'Wall';

            if (surfaceType === 'Wall') {
              reticle.visible = true;
              reticle.matrix = hitMatrix;
              document.getElementById('guidance').style.display = 'none';
            }
          }
        }

        scene.startFrame();
        session.requestAnimationFrame(onXRFrame);
        scene.drawXRFrame(frame, pose);
        scene.endFrame();
      }

      initXR();
    </script>
  </body>
</html>