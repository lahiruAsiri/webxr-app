<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>
    <link rel='icon' type='image/png' sizes='32x32' href='favicon-32x32.png'>
    <link rel='icon' type='image/png' sizes='96x96' href='favicon-96x96.png'>
    <!-- Add Tailwind CSS via CDN for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body { margin: 0; }
      #guidance {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px 20px;
        border-radius: 5px;
        z-index: 1000;
        font-family: Arial, sans-serif;
        display: none;
      }
      #imageSelection {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 1001;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px;
        border-radius: 5px;
        backdrop-filter: blur(5px);
      }
      #loadingStatus {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 1001;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px;
        border-radius: 5px;
        backdrop-filter: blur(5px);
        font-size: 12px;
      }
      .loading { color: orange; }
      .loaded { color: green; }
      .error { color: red; }
    </style>
    <title>PNG Wall Art AR</title>
  </head>
  <body>
    <header>
      <details open>
        <summary>PNG Wall Art AR</summary>
        <p>
          Select your wall art from the dropdown, then point at a wall to see the blue reticle and tap to place your wall art. Use controls to adjust size and position.
          <a class="back" href="./">Back</a>
        </p>
      </details>
    </header>
    
    <!-- Loading Status -->
    <div id="loadingStatus">
      <div id="statusText" class="loading">Loading default image...</div>
    </div>
    
    <!-- Image Selection Section -->
    <div id="imageSelection">
      <select id="imageSelect" class="mb-2 p-2 border rounded">
        <option value="media/images/wallart1.png">Wall Art 1</option>
        <option value="media/images/wallart2.png">Wall Art 2</option>
        <option value="media/images/wallart3.png">Wall Art 3</option>
        <option value="media/images/poster.png">Poster</option>
        <option value="fallback">Use Fallback Pattern</option>
      </select>
      <div class="text-sm text-gray-600">Select your wall art</div>
    </div>
    
    <div id="guidance">Point at a wall to see the blue reticle and place your custom wall art.</div>
    <div class="fixed bottom-4 left-4 z-[1000] font-sans transition-all duration-300" id="controls" style="display: none;">
      <!-- Minimize/Maximize toggle button -->
      <button id="toggleControls" class="absolute -top-10 left-0 bg-blue-600 text-white rounded-full w-10 h-10 flex items-center justify-center hover:bg-blue-700 focus:outline-none shadow-md">
        <span id="toggleIcon">-</span>
      </button>
      <!-- Controls panel -->
      <div id="controlsPanel" class="bg-white p-6 rounded-lg shadow-xl w-100 max-w-xs bg-opacity-90 backdrop-blur-sm">
        <h3 class="text-lg font-semibold text-gray-800 mb-4">Wall Art Controls</h3>
        <div class="space-y-4">
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">Size:</label>
            <input type="range" id="scale" min="0.1" max="3.0" step="0.1" value="1.0" class="w-full accent-blue-600">
          </div>
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">X Position:</label>
            <input type="range" id="posX" min="-1.0" max="1.0" step="0.01" value="0" class="w-full accent-blue-600">
          </div>
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">Y Position:</label>
            <input type="range" id="posY" min="-1.0" max="1.0" step="0.01" value="0" class="w-full accent-blue-600">
          </div>
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">Z Position:</label>
            <input type="range" id="posZ" min="-0.5" max="0.5" step="0.01" value="0.01" class="w-full accent-blue-600">
          </div>
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">Rotation:</label>
            <input type="range" id="rotZ" min="-180" max="180" step="1" value="0" class="w-full accent-blue-600">
          </div>
          <button id="removePoster" class="w-full mt-4 bg-red-500 text-white py-2 rounded-md hover:bg-red-600 focus:outline-none transition-colors">
            Remove Wall Art
          </button>
        </div>
      </div>
    </div>
    <script type="module">
      import {WebXRButton} from './js/util/webxr-button.js';
      import {Scene} from './js/render/scenes/scene.js';
      import {Renderer, createWebGLContext} from './js/render/core/renderer.js';
      import {Node} from './js/render/core/node.js';
      import {Gltf2Node} from './js/render/nodes/gltf2.js';
      import {vec3, mat4, quat} from './js/render/math/gl-matrix.js';
      import {Material, RENDER_ORDER} from './js/render/core/material.js';
      import {Primitive} from './js/render/core/primitive.js';

      // XR globals
      let xrButton = null;
      let xrRefSpace = null;
      let xrViewerSpace = null;
      let xrHitTestSource = null;

      // WebGL scene globals
      let gl = null;
      let renderer = null;
      let scene = new Scene();
      scene.enableStats(false);

      // Image texture globals
      let imageTexture = null;
      let currentImagePath = 'media/images/wallart1.png'; // Default image
      let isImageLoaded = false;

      // Reticle for hit testing
      let reticle = new Gltf2Node({url: 'media/gltf/reticle/reticle.gltf'});
      reticle.onLoad = () => console.log('Reticle GLTF loaded');
      reticle.onError = (error) => console.error('Reticle GLTF error:', error);
      reticle.visible = false;
      scene.addNode(reticle);

      scene.clear = false;

      // Single poster management
      let currentPoster = null;
      let baseMatrix = mat4.create();
      let controls = {
        scale: 1.0,
        posX: 0,
        posY: 0,
        posZ: 0.01,
        rotZ: 0
      };

      // Status update function
      function updateStatus(message, className = 'loading') {
        const statusText = document.getElementById('statusText');
        statusText.textContent = message;
        statusText.className = className;
        if (className === 'error') {
          const alertDiv = document.createElement('div');
          alertDiv.style.cssText = `
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9); color: white; padding: 10px 20px;
            border-radius: 5px; z-index: 1002; font-family: Arial, sans-serif;
          `;
          alertDiv.textContent = message;
          document.body.appendChild(alertDiv);
          setTimeout(() => alertDiv.remove(), 3000);
        }
      }

      // Create a fallback texture with a simple pattern
      function createFallbackTexture() {
        if (!gl) {
          console.error('WebGL context not available for fallback texture');
          updateStatus('WebGL context error', 'error');
          return null;
        }
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 256;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = '#4A90E2';
        ctx.fillRect(0, 0, 256, 256);
        
        ctx.fillStyle = '#FFFFFF';
        ctx.font = '24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('WALL ART', 128, 128);
        
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        for (let i = 0; i < 8; i++) {
          for (let j = 0; j < 8; j++) {
            if ((i + j) % 2 === 0) {
              ctx.fillRect(i * 32, j * 32, 32, 32);
            }
          }
        }
        
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        
        const error = gl.getError();
        if (error !== gl.NO_ERROR) {
          console.error('WebGL error creating fallback texture:', error);
          updateStatus('WebGL texture error', 'error');
          return null;
        }
        
        return texture;
      }

      // Create a plane geometry for the wall art
      function createWallArtGeometry() {
        const vertices = new Float32Array([
          -0.5, -0.5, 0.0,
           0.5, -0.5, 0.0,
           0.5,  0.5, 0.0,
          -0.5,  0.5, 0.0
        ]);

        const normals = new Float32Array([
          0.0, 0.0, 1.0,
          0.0, 0.0, 1.0,
          0.0, 0.0, 1.0,
          0.0, 0.0, 1.0
        ]);

        const texCoords = new Float32Array([
          0.0, 1.0,
          1.0, 1.0,
          1.0, 0.0,
          0.0, 0.0
        ]);

        const indices = new Uint16Array([
          0, 1, 2, 0, 2, 3
        ]);

        return { vertices, normals, texCoords, indices };
      }

      // Create wall art node with custom PNG
      function createWallArtNode(texture) {
        if (!gl) {
          console.error('WebGL context not available');
          updateStatus('WebGL context error', 'error');
          return null;
        }
        if (!texture) {
          console.error('No valid texture provided');
          updateStatus('Texture error', 'error');
          return null;
        }

        console.log('Creating wall art node with texture:', texture);
        const geometry = createWallArtGeometry();
        
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, geometry.vertices, gl.STATIC_DRAW);

        const normalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, geometry.normals, gl.STATIC_DRAW);

        const texCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, geometry.texCoords, gl.STATIC_DRAW);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, geometry.indices, gl.STATIC_DRAW);

        const material = new Material();
        material.baseColorTexture = texture;
        material.transparent = true;
        material.renderOrder = RENDER_ORDER.TRANSPARENT;

        const primitive = new Primitive({
          POSITION: vertexBuffer,
          NORMAL: normalBuffer,
          TEXCOORD_0: texCoordBuffer
        }, indexBuffer, material, gl.TRIANGLES);

        const node = new Node();
        node.addRenderPrimitive(primitive);
        console.log('Wall art node created:', node);
        return node;
      }

      // Load texture from image with better error handling
      function loadTexture(imageUrl) {
        return new Promise((resolve, reject) => {
          if (!gl) {
            console.error('WebGL context not initialized');
            updateStatus('WebGL context error, using fallback', 'error');
            resolve(createFallbackTexture());
            return;
          }

          updateStatus(`Loading ${imageUrl}...`, 'loading');
          
          if (imageUrl === 'fallback') {
            setTimeout(() => {
              const texture = createFallbackTexture();
              updateStatus('Using fallback pattern', 'loaded');
              resolve(texture);
            }, 100);
            return;
          }
          
          const texture = gl.createTexture();
          const image = new Image();
          
          const timeout = setTimeout(() => {
            console.warn(`Timeout loading ${imageUrl} after 15s`);
            updateStatus(`Timeout loading ${imageUrl}, using fallback`, 'error');
            resolve(createFallbackTexture());
          }, 15000);
          
          image.onload = () => {
            clearTimeout(timeout);
            try {
              gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
              const error = gl.getError();
              if (error !== gl.NO_ERROR) {
                throw new Error(`WebGL error ${error} while loading texture`);
              }
              
              const isPowerOf2 = (value) => (value & (value - 1)) === 0;
              if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
                gl.generateMipmap(gl.TEXTURE_2D);
              } else {
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
              }
              
              updateStatus(`Loaded: ${imageUrl}`, 'loaded');
              resolve(texture);
            } catch (error) {
              console.error(`Texture processing error for ${imageUrl}:`, error);
              updateStatus(`Error processing ${imageUrl}, using fallback`, 'error');
              resolve(createFallbackTexture());
            }
          };
          
          image.onerror = () => {
            clearTimeout(timeout);
            console.error(`Failed to load image: ${imageUrl}`);
            updateStatus(`Failed to load ${imageUrl}, using fallback`, 'error');
            resolve(createFallbackTexture());
          };
          
          image.crossOrigin = 'anonymous';
          image.src = imageUrl;
          
          setTimeout(() => {
            if (!image.complete) {
              console.log(`Retrying ${imageUrl} without CORS`);
              const img2 = new Image();
              img2.onload = () => {
                clearTimeout(timeout);
                try {
                  gl.bindTexture(gl.TEXTURE_2D, texture);
                  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img2);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                  updateStatus(`Loaded: ${imageUrl} (no CORS)`, 'loaded');
                  resolve(texture);
                } catch (error) {
                  console.error(`Non-CORS load error for ${imageUrl}:`, error);
                  resolve(createFallbackTexture());
                }
              };
              img2.onerror = () => {
                console.error(`Non-CORS load failed for ${imageUrl}`);
                resolve(createFallbackTexture());
              };
              img2.src = imageUrl;
            }
          }, 2000);
        });
      }

      function updatePosterTransform() {
        if (!currentPoster) {
          console.log('No poster to transform');
          return;
        }

        console.log('Updating poster transform with controls:', controls);
        let matrix = mat4.clone(baseMatrix);
        let position = vec3.create();
        let rotation = quat.create();
        mat4.getTranslation(position, matrix);
        mat4.getRotation(rotation, matrix);

        let offset = vec3.fromValues(controls.posX, controls.posY, controls.posZ);
        vec3.add(position, position, offset);

        let zRotation = quat.create();
        quat.fromEuler(zRotation, 0, 0, controls.rotZ);
        quat.multiply(rotation, rotation, zRotation);

        let scaleMatrix = mat4.create();
        mat4.fromScaling(scaleMatrix, [controls.scale, controls.scale, controls.scale]);
        let transformMatrix = mat4.create();
        mat4.fromRotationTranslation(transformMatrix, rotation, position);
        mat4.multiply(transformMatrix, transformMatrix, scaleMatrix);

        currentPoster.matrix = transformMatrix;
        console.log('Poster matrix updated:', transformMatrix);

        document.getElementById('scale').value = controls.scale;
        document.getElementById('posX').value = controls.posX;
        document.getElementById('posY').value = controls.posY;
        document.getElementById('posZ').value = controls.posZ;
_character_0_document.getElementById('rotZ').value = controls.rotZ;
      }

      // Handle image selection
      function handleImageSelection(event) {
        const selectedPath = event.target.value;
        currentImagePath = selectedPath;
        isImageLoaded = false;
        
        console.log('Selected image:', selectedPath);
        loadTexture(selectedPath).then(texture => {
          imageTexture = texture;
          isImageLoaded = true;
          console.log('Image loaded successfully:', selectedPath);
          
          if (currentPoster) {
            console.log('Updating existing poster with new texture');
            scene.removeNode(currentPoster);
            createWallArtAtCurrentPosition();
          }
        }).catch(error => {
          console.error('Error loading image:', error);
          imageTexture = createFallbackTexture();
          isImageLoaded = true;
          updateStatus('Using fallback pattern due to error', 'error');
        });
      }

      // Create wall art at current position (for texture updates)
      function createWallArtAtCurrentPosition() {
        if (!imageTexture || !baseMatrix) {
          console.error('Cannot create wall art: missing texture or baseMatrix');
          return;
        }
        
        let wallArtNode = createWallArtNode(imageTexture);
        if (!wallArtNode) {
          console.error('Failed to create wall art node');
          return;
        }
        wallArtNode.visible = true;
        currentPoster = wallArtNode;
        
        updatePosterTransform();
        scene.addNode(wallArtNode);
        console.log('Wall art node added for texture update');
      }

      function initXR() {
        xrButton = new WebXRButton({
          onRequestSession: onRequestSession,
          onEndSession: onEndSession,
          textEnterXRTitle: "START AR",
          textXRNotFoundTitle: "AR NOT FOUND",
          textExitXRTitle: "EXIT AR",
        });
        document.querySelector('header').appendChild(xrButton.domElement);

        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-ar')
            .then((supported) => {
              xrButton.enabled = supported;
              console.log('Immersive AR supported:', supported);
            }).catch(error => {
              console.error('Error checking AR support:', error);
            });
        } else {
          console.error('WebXR not supported');
          updateStatus('WebXR not supported', 'error');
        }

        document.getElementById('imageSelect').addEventListener('change', handleImageSelection);

        document.getElementById('scale').addEventListener('input', (e) => {
          controls.scale = parseFloat(e.target.value);
          updatePosterTransform();
        });
        document.getElementById('posX').addEventListener('input', (e) => {
          controls.posX = parseFloat(e.target.value);
          updatePosterTransform();
        });
        document.getElementById('posY').addEventListener('input', (e) => {
          controls.posY = parseFloat(e.target.value);
          updatePosterTransform();
        });
        document.getElementById('posZ').addEventListener('input', (e) => {
          controls.posZ = parseFloat(e.target.value);
          updatePosterTransform();
        });
        document.getElementById('rotZ').addEventListener('input', (e) => {
          controls.rotZ = parseFloat(e.target.value);
          updatePosterTransform();
        });
        document.getElementById('removePoster').addEventListener('click', () => {
          if (currentPoster) {
            scene.removeNode(currentPoster);
            currentPoster = null;
            document.getElementById('controls').style.display = 'none';
            document.getElementById('guidance').style.display = 'block';
            controls = { scale: 1.0, posX: 0, posY: 0, posZ: 0.01, rotZ: 0 };
            updatePosterTransform();
            console.log('Poster removed');
          }
        });

        document.getElementById('toggleControls').addEventListener('click', () => {
          const controlsPanel = document.getElementById('controlsPanel');
          const toggleIcon = document.getElementById('toggleIcon');
          if (controlsPanel.style.display === 'none') {
            controlsPanel.style.display = 'block';
            toggleIcon.textContent = '-';
          } else {
            controlsPanel.style.display = 'none';
            toggleIcon.textContent = '+';
          }
        });

        // Preload default texture
        loadTexture(currentImagePath).then(texture => {
          imageTexture = texture;
          isImageLoaded = true;
          console.log('Preloaded default image:', currentImagePath);
        }).catch(error => {
          console.error('Preload error:', error);
          imageTexture = createFallbackTexture();
          isImageLoaded = true;
          updateStatus('Using fallback pattern', 'loaded');
        });
      }

      function onRequestSession() {
        console.log('Requesting AR session');
        return navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['local', 'dom-overlay'],
          optionalFeatures: ['hit-test'],
          domOverlay: { root: document.body }
        }).then((session) => {
          console.log('AR session started');
          xrButton.setSession(session);
          onSessionStarted(session);
        }).catch((error) => {
          console.error('AR session error:', error);
          updateStatus(`AR Session Error: ${error.message}`, 'error');
        });
      }

      function onSessionStarted(session) {
        session.addEventListener('end', onSessionEnded);
        session.addEventListener('select', onSelect);

        if (!gl) {
          try {
            gl = createWebGLContext({
              xrCompatible: true,
              alpha: true
            });
            if (!gl) {
              throw new Error('Failed to create WebGL context');
            }
            renderer = new Renderer(gl);
            scene.setRenderer(renderer);
            console.log('WebGL context initialized');
          } catch (error) {
            console.error('WebGL error:', error);
            updateStatus(`WebGL Error: ${error.message}`, 'error');
            session.end();
            return;
          }
        }

        try {
          session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });
          console.log('XRWebGLLayer initialized');
        } catch (error) {
          console.error('XRWebGLLayer error:', error);
          updateStatus(`XRWebGLLayer Error: ${error.message}`, 'error');
          session.end();
          return;
        }

        session.requestReferenceSpace('viewer').then((refSpace) => {
          xrViewerSpace = refSpace;
          session.requestHitTestSource({ space: xrViewerSpace }).then((hitTestSource) => {
            xrHitTestSource = hitTestSource;
            console.log('Hit test source initialized');
          }).catch((error) => {
            console.warn('HitTest initialization failed:', error);
            updateStatus('Hit test not supported', 'error');
          });
        });

        session.requestReferenceSpace('local').then((refSpace) => {
          xrRefSpace = refSpace;
          session.requestAnimationFrame(onXRFrame);
          console.log('Local reference space initialized');
        }).catch((error) => {
          console.error('RefSpace error:', error);
          updateStatus(`RefSpace Error: ${error.message}`, 'error');
        });

        document.getElementById('guidance').style.display = 'block';
      }

      function onEndSession(session) {
        if (xrHitTestSource) {
          xrHitTestSource.cancel();
          xrHitTestSource = null;
        }
        session.end();
        console.log('AR session ended');
      }

      function onSessionEnded(event) {
        xrButton.setSession(null);
        console.log('Session ended event');
      }

      async function addARObjectAt(matrix) {
        if (!imageTexture || !isImageLoaded) {
          console.warn('No valid texture, using fallback');
          imageTexture = createFallbackTexture();
          isImageLoaded = true;
          updateStatus('Using fallback pattern', 'loaded');
        }

        if (currentPoster) {
          console.log('Poster already exists, skipping placement');
          return;
        }

        let hitMatrix = mat4.clone(matrix);
        let position = vec3.create();
        let rotation = quat.create();
        mat4.getTranslation(position, hitMatrix);
        mat4.getRotation(rotation, hitMatrix);
        console.log('Placing poster at position:', position);

        let upVector = vec3.fromValues(0, 1, 0);
        vec3.transformQuat(upVector, upVector, rotation);
        vec3.normalize(upVector, upVector);

        let surfaceNormal = vec3.create();
        let surfaceType = Math.abs(upVector[1]) > 0.5 ? 'Floor' : 'Wall';
        console.log('Surface type:', surfaceType, 'Up vector Y:', upVector[1]);

        if (surfaceType !== 'Wall') {
          console.log('Not a wall, skipping placement');
          updateStatus('Please point at a wall', 'error');
          return;
        }

        let wallArtNode = createWallArtNode(imageTexture);
        if (!wallArtNode) {
          console.error('Failed to create wall art node');
          updateStatus('Failed to create wall art', 'error');
          return;
        }
        wallArtNode.visible = true;

        // Simplified transformation for testing
        let finalMatrix = mat4.clone(hitMatrix);
        baseMatrix = mat4.clone(finalMatrix);
        currentPoster = wallArtNode;

        updatePosterTransform();
        scene.addNode(wallArtNode);
        console.log('Wall art node added to scene at:', finalMatrix);

        document.getElementById('controls').style.display = 'block';
        document.getElementById('guidance').style.display = 'none';
        updateStatus('Wall art placed successfully!', 'loaded');
      }

      function onSelect(event) {
        console.log('Select event triggered:', event);
        if (reticle.visible) {
          console.log('Reticle visible, attempting to place poster');
          addARObjectAt(reticle.matrix);
        } else {
          console.log('Reticle not visible, cannot place poster');
          updateStatus('Point at a wall to place art', 'error');
        }
      }

      function onXRFrame(t, frame) {
        let session = frame.session;
        let pose = frame.getViewerPose(xrRefSpace);

        reticle.visible = false;
        document.getElementById('guidance').style.display = currentPoster ? 'none' : 'block';

        if (xrHitTestSource && pose && !currentPoster) {
          let hitTestResults = frame.getHitTestResults(xrHitTestSource);
          console.log('Hit test results:', hitTestResults.length);
          if (hitTestResults.length > 0) {
            let hitPose = hitTestResults[0].getPose(xrRefSpace);
            let hitMatrix = hitPose.transform.matrix;
            let position = vec3.create();
            let rotation = quat.create();
            mat4.getTranslation(position, hitMatrix);
            mat4.getRotation(rotation, hitMatrix);
            console.log('Hit position:', position);

            let upVector = vec3.fromValues(0, 1, 0);
            vec3.transformQuat(upVector, upVector, rotation);
            vec3.normalize(upVector, upVector);
            let surfaceType = Math.abs(upVector[1]) > 0.5 ? 'Floor' : 'Wall';
            console.log('Surface type:', surfaceType, 'Up vector Y:', upVector[1]);

            if (surfaceType === 'Wall') {
              reticle.visible = true;
              reticle.matrix = hitMatrix;
              document.getElementById('guidance').style.display = 'none';
              console.log('Reticle shown at:', position);
            }
          }
        }

        scene.startFrame();
        session.requestAnimationFrame(onXRFrame);
        scene.drawXRFrame(frame, pose);
        scene.endFrame();
      }

      // Initialize everything
      initXR();
      
      // Pre-load fallback texture when WebGL is available
      window.addEventListener('load', () => {
        setTimeout(() => {
          if (gl && !imageTexture) {
            imageTexture = createFallbackTexture();
            isImageLoaded = true;
            updateStatus('Fallback pattern ready', 'loaded');
          }
        }, 1000);
      });
    </script>
  </body>
</html>