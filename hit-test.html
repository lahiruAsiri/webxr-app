<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>
    <link rel='icon' type='image/png' sizes='32x32' href='favicon-32x32.png'>
    <link rel='icon' type='image/png' sizes='96x96' href='favicon-96x96.png'>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body { margin: 0; }
      #guidance {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px 20px;
        border-radius: 5px;
        z-index: 1000;
        font-family: Arial, sans-serif;
        display: none;
      }
      #debug {
        position: fixed;
        bottom: 0;
        left: 0;
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 10px;
        z-index: 1000;
        font-family: monospace;
        font-size: 14px;
        max-width: 100%;
        overflow: auto;
        max-height: 100px;
      }
    </style>
    <title>AR Wall Art</title>
  </head>
  <body>
    <header>
      <details open>
        <summary>AR Wall Art</summary>
        <p>
          Point at a wall to see the blue reticle, then tap to place your artwork. 
          Use controls to adjust position and rotation.
          <a class="back" href="./">Back</a>
        </p>
      </details>
    </header>
    <div id="guidance">Point at a wall to place your artwork.</div>
    <div id="debug"></div>
    
    <div class="fixed bottom-4 left-4 z-[1000] font-sans transition-all duration-300" id="controls" style="display: none;">
      <button id="toggleControls" class="absolute -top-10 left-0 bg-blue-600 text-white rounded-full w-10 h-10 flex items-center justify-center hover:bg-blue-700 focus:outline-none shadow-md">
        <span id="toggleIcon">-</span>
      </button>
      <div id="controlsPanel" class="bg-white p-6 rounded-lg shadow-xl w-100 max-w-xs bg-opacity-90 backdrop-blur-sm">
        <h3 class="text-lg font-semibold text-gray-800 mb-4">Artwork Controls</h3>
        <div class="space-y-4">
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">Size:</label>
            <input type="range" id="scale" min="0.1" max="2.0" step="0.1" value="0.5" class="w-full accent-blue-600">
          </div>
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">X Position:</label>
            <input type="range" id="posX" min="-0.5" max="0.5" step="0.01" value="0" class="w-full accent-blue-600">
          </div>
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">Y Position:</label>
            <input type="range" id="posY" min="-0.5" max="0.5" step="0.01" value="0" class="w-full accent-blue-600">
          </div>
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">Z Position:</label>
            <input type="range" id="posZ" min="-0.5" max="0.5" step="0.01" value="0" class="w-full accent-blue-600">
          </div>
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">X Rotation:</label>
            <input type="range" id="rotX" min="-180" max="180" step="1" value="0" class="w-full accent-blue-600">
          </div>
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">Y Rotation:</label>
            <input type="range" id="rotY" min="-180" max="180" step="1" value="0" class="w-full accent-blue-600">
          </div>
          <div class="flex items-center space-x-4">
            <label class="w-20 text-sm text-gray-600">Z Rotation:</label>
            <input type="range" id="rotZ" min="-180" max="180" step="1" value="0" class="w-full accent-blue-600">
          </div>
          <button id="removePoster" class="w-full mt-4 bg-red-500 text-white py-2 rounded-md hover:bg-red-600 focus:outline-none transition-colors">
            Remove Artwork
          </button>
        </div>
      </div>
    </div>

    <script type="module">
      import {WebXRButton} from './js/util/webxr-button.js';
      import {Scene} from './js/render/scenes/scene.js';
      import {Renderer, createWebGLContext} from './js/render/core/renderer.js';
      import {Node} from './js/render/core/node.js';
      import {vec3, mat4, quat} from './js/render/math/gl-matrix.js';
      import {Ray} from './js/render/math/ray.js';

      // Debugging system
      function logDebug(message) {
        console.log('[DEBUG]', message);
        const debugDiv = document.getElementById('debug');
        debugDiv.textContent += message + '\n';
        debugDiv.scrollTop = debugDiv.scrollHeight;
      }

      // XR globals
      let xrButton = null;
      let xrRefSpace = null;
      let xrViewerSpace = null;
      let xrHitTestSource = null;

      // WebGL scene globals
      let gl = null;
      let shaderProgram = null;
      let attribLocations = null;
      let uniformLocations = null;
      
      let scene = new Scene();
      scene.enableStats(false);

      let arObject = new Node();
      arObject.visible = false;
      scene.addNode(arObject);

      // Reticle setup
      let reticle = null;
      function createReticle() {
        reticle = new Node();
        reticle.visible = false;
        
        // Create a simple circle geometry for the reticle
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        
        // Draw blue reticle
        ctx.beginPath();
        ctx.arc(32, 32, 30, 0, 2 * Math.PI);
        ctx.strokeStyle = '#00aaff';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        ctx.beginPath();
        ctx.arc(32, 32, 20, 0, 2 * Math.PI);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.arc(32, 32, 10, 0, 2 * Math.PI);
        ctx.stroke();
        
        // Create WebGL texture
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        
        // Create geometry (smaller than artwork)
        const positions = new Float32Array([
          -0.1, -0.1, 0,
          0.1, -0.1, 0,
          -0.1, 0.1, 0,
          0.1, 0.1, 0
        ]);
        
        const texCoords = new Float32Array([
          0, 0,
          1, 0,
          0, 1,
          1, 1
        ]);
        
        const indices = new Uint16Array([0, 1, 2, 2, 1, 3]);
        
        // Create buffers
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
        
        const texCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);
        
        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
        
        // Store references
        reticle._positionBuffer = positionBuffer;
        reticle._texCoordBuffer = texCoordBuffer;
        reticle._indexBuffer = indexBuffer;
        reticle._texture = texture;
        reticle._indicesCount = indices.length;
        
        scene.addNode(reticle);
        logDebug('Reticle created successfully');
      }

      // Artwork management
      let currentPoster = null;
      let baseMatrix = mat4.create();
      let controls = {
        scale: 0.5,
        posX: 0,
        posY: 0,
        posZ: 0,
        rotX: 0,
        rotY: 90,
        rotZ: 0
      };

      function createImagePlaneNode(imageUrl) {
        logDebug(`Creating image plane with: ${imageUrl}`);
        
        const plane = new Node();
        plane.visible = true;
        
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 1024;
        const ctx = canvas.getContext('2d');
        
        // Initial debug pattern
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ffffff';
        ctx.font = '30px Arial';
        ctx.fillText('Loading...', 50, 50);
        
        const img = new Image();
        img.crossOrigin = 'anonymous';
        
        img.onload = function() {
          logDebug('Image loaded successfully');
          
          const aspect = img.width / img.height;
          let drawWidth, drawHeight;
          
          if (aspect > 1) {
            drawWidth = canvas.width;
            drawHeight = canvas.width / aspect;
          } else {
            drawHeight = canvas.height;
            drawWidth = canvas.height * aspect;
          }
          
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 
            (canvas.width - drawWidth) / 2, 
            (canvas.height - drawHeight) / 2,
            drawWidth, 
            drawHeight
          );
          
          try {
            // Create WebGL texture directly
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            
            logDebug('WebGL texture created successfully');
            
            // Create simple geometry
            const positions = new Float32Array([
              -0.5, -0.5, 0,
              0.5, -0.5, 0,
              -0.5, 0.5, 0,
              0.5, 0.5, 0
            ]);
            
            const texCoords = new Float32Array([
              0, 0,
              1, 0,
              0, 1,
              1, 1
            ]);
            
            const indices = new Uint16Array([0, 1, 2, 2, 1, 3]);
            
            // Create buffers
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
            
            const texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);
            
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
            
            // Store references on the plane node
            plane._positionBuffer = positionBuffer;
            plane._texCoordBuffer = texCoordBuffer;
            plane._indexBuffer = indexBuffer;
            plane._texture = texture;
            plane._indicesCount = indices.length;
            
            logDebug('Geometry buffers created successfully');
          } catch (error) {
            logDebug(`Error creating WebGL resources: ${error.message}`);
            console.error(error);
          }
        };
        
        img.onerror = function() {
          logDebug(`Error loading image: ${imageUrl}`);
          ctx.fillStyle = '#00ff00';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = '#000000';
          ctx.font = '30px Arial';
          ctx.fillText('Image Error', 50, 50);
        };
        
        img.src = imageUrl;
        return plane;
      }

      function updatePosterTransform() {
        if (!currentPoster) return;

        let matrix = mat4.clone(baseMatrix);
        let position = vec3.create();
        let rotation = quat.create();
        mat4.getTranslation(position, matrix);
        mat4.getRotation(rotation, matrix);

        // Apply position offsets
        let offset = vec3.fromValues(controls.posX, controls.posY, controls.posZ);
        vec3.add(position, position, offset);

        // Apply user rotations
        let userRotation = quat.create();
        quat.fromEuler(userRotation, controls.rotX, controls.rotY, controls.rotZ);
        quat.multiply(rotation, rotation, userRotation);

        // Apply scale
        let scaleMatrix = mat4.create();
        mat4.fromScaling(scaleMatrix, [controls.scale, controls.scale, controls.scale]);
        let transformMatrix = mat4.create();
        mat4.fromRotationTranslation(transformMatrix, rotation, position);
        mat4.multiply(transformMatrix, transformMatrix, scaleMatrix);

        currentPoster.matrix = transformMatrix;

        // Update sliders
        document.getElementById('scale').value = controls.scale;
        document.getElementById('posX').value = controls.posX;
        document.getElementById('posY').value = controls.posY;
        document.getElementById('posZ').value = controls.posZ;
        document.getElementById('rotX').value = controls.rotX;
        document.getElementById('rotY').value = controls.rotY;
        document.getElementById('rotZ').value = controls.rotZ;
      }

      function initShaderProgram() {
        const vsSource = `
          attribute vec3 aPosition;
          attribute vec2 aTexCoord;
          uniform mat4 uModelViewMatrix;
          uniform mat4 uProjectionMatrix;
          varying vec2 vTexCoord;
          void main() {
            gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
            vTexCoord = aTexCoord;
          }
        `;
        
        const fsSource = `
          precision mediump float;
          varying vec2 vTexCoord;
          uniform sampler2D uSampler;
          void main() {
            gl_FragColor = texture2D(uSampler, vTexCoord);
          }
        `;
        
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vsSource);
        gl.compileShader(vertexShader);
        
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fsSource);
        gl.compileShader(fragmentShader);
        
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          logDebug(`Shader program link error: ${gl.getProgramInfoLog(program)}`);
          return null;
        }
        
        return {
          program: program,
          attribLocations: {
            position: gl.getAttribLocation(program, 'aPosition'),
            texCoord: gl.getAttribLocation(program, 'aTexCoord')
          },
          uniformLocations: {
            projectionMatrix: gl.getUniformLocation(program, 'uProjectionMatrix'),
            modelViewMatrix: gl.getUniformLocation(program, 'uModelViewMatrix'),
            sampler: gl.getUniformLocation(program, 'uSampler')
          }
        };
      }

      function drawNode(node, viewMatrix) {
        if (!node.visible || !node._positionBuffer) return;
        
        const modelViewMatrix = mat4.create();
        mat4.multiply(modelViewMatrix, viewMatrix, node.matrix);
        
        gl.uniformMatrix4fv(
          uniformLocations.modelViewMatrix,
          false,
          modelViewMatrix
        );
        
        // Position attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, node._positionBuffer);
        gl.vertexAttribPointer(
          attribLocations.position,
          3,
          gl.FLOAT,
          false,
          0,
          0
        );
        gl.enableVertexAttribArray(attribLocations.position);
        
        // Texture coordinate attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, node._texCoordBuffer);
        gl.vertexAttribPointer(
          attribLocations.texCoord,
          2,
          gl.FLOAT,
          false,
          0,
          0
        );
        gl.enableVertexAttribArray(attribLocations.texCoord);
        
        // Bind texture
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, node._texture);
        gl.uniform1i(uniformLocations.sampler, 0);
        
        // Draw elements
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, node._indexBuffer);
        gl.drawElements(
          gl.TRIANGLES,
          node._indicesCount,
          gl.UNSIGNED_SHORT,
          0
        );
      }

      function initXR() {
        xrButton = new WebXRButton({
          onRequestSession: onRequestSession,
          onEndSession: onEndSession,
          textEnterXRTitle: "START AR",
          textXRNotFoundTitle: "AR NOT FOUND",
          textExitXRTitle: "EXIT AR",
        });
        document.querySelector('header').appendChild(xrButton.domElement);

        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-ar')
            .then((supported) => {
              xrButton.enabled = supported;
            });
        }

        // Control listeners
        document.getElementById('scale').addEventListener('input', (e) => {
          controls.scale = parseFloat(e.target.value);
          updatePosterTransform();
        });
        document.getElementById('posX').addEventListener('input', (e) => {
          controls.posX = parseFloat(e.target.value);
          updatePosterTransform();
        });
        document.getElementById('posY').addEventListener('input', (e) => {
          controls.posY = parseFloat(e.target.value);
          updatePosterTransform();
        });
        document.getElementById('posZ').addEventListener('input', (e) => {
          controls.posZ = parseFloat(e.target.value);
          updatePosterTransform();
        });
        document.getElementById('rotX').addEventListener('input', (e) => {
          controls.rotX = parseFloat(e.target.value);
          updatePosterTransform();
        });
        document.getElementById('rotY').addEventListener('input', (e) => {
          controls.rotY = parseFloat(e.target.value);
          updatePosterTransform();
        });
        document.getElementById('rotZ').addEventListener('input', (e) => {
          controls.rotZ = parseFloat(e.target.value);
          updatePosterTransform();
        });
        document.getElementById('removePoster').addEventListener('click', () => {
          if (currentPoster) {
            scene.removeNode(currentPoster);
            currentPoster = null;
            document.getElementById('controls').style.display = 'none';
            document.getElementById('guidance').style.display = 'block';
            controls = { scale: 0.5, posX: 0, posY: 0, posZ: 0, rotX: 0, rotY: 90, rotZ: 0 };
            updatePosterTransform();
          }
        });

        document.getElementById('toggleControls').addEventListener('click', () => {
          const controlsPanel = document.getElementById('controlsPanel');
          const toggleIcon = document.getElementById('toggleIcon');
          if (controlsPanel.style.display === 'none') {
            controlsPanel.style.display = 'block';
            toggleIcon.textContent = '-';
          } else {
            controlsPanel.style.display = 'none';
            toggleIcon.textContent = '+';
          }
        });
      }

      function onRequestSession() {
        return navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['local', 'dom-overlay'],
          optionalFeatures: ['hit-test'],
          domOverlay: { root: document.body }
        }).then((session) => {
          xrButton.setSession(session);
          onSessionStarted(session);
        }).catch((error) => {
          alert(`AR Session Error: ${error.message}`);
        });
      }

      let lastPose = null;
      function onSessionStarted(session) {
        session.addEventListener('end', onSessionEnded);
        session.addEventListener('select', onSelect);

        if (!gl) {
          try {
            gl = createWebGLContext({
              xrCompatible: true,
              alpha: true,
              preserveDrawingBuffer: true
            });
            if (!gl) {
              alert('Error: Failed to create WebGL context');
              session.end();
              return;
            }
            
            // Initialize shader program
            const shaderInfo = initShaderProgram();
            if (!shaderInfo) {
              alert('Error: Failed to initialize shader program');
              session.end();
              return;
            }
            
            shaderProgram = shaderInfo.program;
            attribLocations = shaderInfo.attribLocations;
            uniformLocations = shaderInfo.uniformLocations;
            
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            
            logDebug('WebGL context and shaders created successfully');
            
            // Create reticle after WebGL is ready
            createReticle();
            
          } catch (error) {
            alert(`WebGL Error: ${error.message}`);
            session.end();
            return;
          }
        }

        try {
          session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });
        } catch (error) {
          alert(`XRWebGLLayer Error: ${error.message}`);
          session.end();
          return;
        }

        session.requestReferenceSpace('viewer').then((refSpace) => {
          xrViewerSpace = refSpace;
          session.requestHitTestSource({ space: xrViewerSpace }).then((hitTestSource) => {
            xrHitTestSource = hitTestSource;
            logDebug('Hit test source created');
          }).catch((error) => {
            logDebug(`HitTest Error: ${error.message}`);
          });
        });

        session.requestReferenceSpace('local').then((refSpace) => {
          xrRefSpace = refSpace;
          session.requestAnimationFrame(onXRFrame);
          logDebug('XR session started successfully');
        }).catch((error) => {
          logDebug(`RefSpace Error: ${error.message}`);
        });

        document.getElementById('guidance').style.display = 'block';
      }

      function onEndSession(session) {
        if (xrHitTestSource) {
          xrHitTestSource.cancel();
          xrHitTestSource = null;
        }
        session.end();
      }

      function onSessionEnded(event) {
        xrButton.setSession(null);
        logDebug('XR session ended');
      }

      function addARObjectAt(matrix) {
        if (currentPoster) return;

        logDebug('Attempting to place artwork');
        
        try {
          let hitMatrix = mat4.clone(matrix);
          let position = vec3.create();
          let rotation = quat.create();
          mat4.getTranslation(position, hitMatrix);
          mat4.getRotation(rotation, hitMatrix);

          let upVector = vec3.fromValues(0, 1, 0);
          vec3.transformQuat(upVector, upVector, rotation);
          vec3.normalize(upVector, upVector);

          let surfaceNormal = vec3.create();
          let surfaceType = '';
          if (Math.abs(upVector[1]) > 0.7) {
            surfaceNormal = vec3.clone(upVector);
            surfaceType = 'Floor';
          } else {
            let viewerForward = vec3.fromValues(-90, 0, 0);
            vec3.transformQuat(viewerForward, viewerForward, rotation);
            surfaceNormal = vec3.fromValues(viewerForward[0], 0, viewerForward[2]);
            vec3.normalize(surfaceNormal, surfaceNormal);
            vec3.negate(surfaceNormal, surfaceNormal);
            surfaceType = 'Wall';
          }

          if (surfaceType !== 'Wall') {
            logDebug('Not placing on wall surface');
            return;
          }

          let modelZ = vec3.fromValues(0, 0, -1);
          let alignRotation = quat.create();
          quat.rotationTo(alignRotation, modelZ, surfaceNormal);

          let finalMatrix = mat4.create();
          let offset = vec3.scale(vec3.create(), surfaceNormal, 0.01);
          vec3.add(position, position, offset);
          mat4.fromRotationTranslation(finalMatrix, rotation, position);
          mat4.multiply(finalMatrix, finalMatrix, mat4.fromQuat(mat4.create(), alignRotation));

          let yRotationQuat = quat.create();
          quat.fromEuler(yRotationQuat, 0, 90, 0);
          let yRotationMatrix = mat4.fromQuat(mat4.create(), yRotationQuat);
          mat4.multiply(finalMatrix, finalMatrix, yRotationMatrix);

          // Update this path to your actual image
          let newObject = createImagePlaneNode('media/images/wallart.png');
          newObject.visible = true;
          currentPoster = newObject;
          baseMatrix = mat4.clone(finalMatrix);

          updatePosterTransform();
          scene.addNode(newObject);
          
          logDebug('Artwork placed successfully');

          document.getElementById('controls').style.display = 'block';
          document.getElementById('guidance').style.display = 'none';
        } catch (error) {
          logDebug(`Error placing artwork: ${error.message}`);
          console.error(error);
        }
      }

      function onSelect(event) {
        if (reticle.visible) {
          addARObjectAt(reticle.matrix);
        }
      }

      function onXRFrame(t, frame) {
        let session = frame.session;
        let pose = frame.getViewerPose(xrRefSpace);
        lastPose = pose;

        reticle.visible = false;
        document.getElementById('guidance').style.display = currentPoster ? 'none' : 'block';

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.useProgram(shaderProgram);

        // Clear the canvas
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        if (xrHitTestSource && pose && !currentPoster) {
          let hitTestResults = frame.getHitTestResults(xrHitTestSource);
          if (hitTestResults.length > 0) {
            let hitPose = hitTestResults[0].getPose(xrRefSpace);
            let hitMatrix = hitPose.transform.matrix;
            let position = vec3.create();
            let rotation = quat.create();
            mat4.getTranslation(position, hitMatrix);
            mat4.getRotation(rotation, hitMatrix);

            let upVector = vec3.fromValues(0, 1, 0);
            vec3.transformQuat(upVector, upVector, rotation);
            vec3.normalize(upVector, upVector);

            let surfaceType = Math.abs(upVector[1]) > 0.7 ? 'Floor' : 'Wall';

            if (surfaceType === 'Wall') {
              reticle.visible = true;
              reticle.matrix = hitMatrix;
              document.getElementById('guidance').style.display = 'none';
            }
          }
        }

        // Set up projection matrix
        const projectionMatrix = mat4.create();
        if (pose) {
          for (const view of pose.views) {
            const viewport = view.viewport;
            gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
            
            mat4.perspective(projectionMatrix, view.fov.angleUp * 2, 
                            viewport.width / viewport.height, 0.1, 1000.0);
            gl.uniformMatrix4fv(
              uniformLocations.projectionMatrix,
              false,
              projectionMatrix
            );
            
            // Draw the reticle
            if (reticle.visible) {
              drawNode(reticle, view.transform.inverse.matrix);
            }
            
            // Draw the current poster
            if (currentPoster) {
              drawNode(currentPoster, view.transform.inverse.matrix);
            }
          }
        }

        session.requestAnimationFrame(onXRFrame);
      }

      initXR();
    </script>
  </body>
</html>